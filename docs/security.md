# セキュリティ（秘密情報 / 暗号化）

## 目的

- **事故を防ぐ**: APIキー等の秘密情報が漏れない運用と構造を固定化する
- **初見で迷わない**: どこに何が保存され、何をコミットしてはいけないかを明確にする

## 何が「秘密」か

- **Groq API Key**（`GROQ_API_KEY` または Settings から保存する値）
- **暗号化マスターキー**（`APP_CONFIG_ENCRYPTION_KEY`）
- `.env.local` / `.env` に書かれる各種キー類

> 注意: `.env.local` は `.gitignore` により基本的にコミットされません。絶対にリポジトリに貼らないでください。

## 保存場所（どこに残るか）

### 1) 環境変数（`.env.local` など）

- ローカル開発向けの推奨は `.env.local`
- 例: `GROQ_API_KEY`, `MODEL_ID`, `LMSTUDIO_BASE_URL`

### 2) DB（SQLite / Prisma）

Settings 画面で Groq API Key を保存する（Option B）場合、DBには **暗号化済み** の値が入ります。

- 暗号方式: **AES-256-GCM**
- マスターキー: `APP_CONFIG_ENCRYPTION_KEY`（**DBには保存しない**）
- 実装: `lib/appConfigEncryption.ts`

## 運用ベストプラクティス

### 1) キーのローテーション（漏洩が疑われる場合）

- **Groq API Key**
  - Groq 側でキーを無効化/再発行
  - ローカルの `GROQ_API_KEY` を更新（Option A）
  - Option B を使っている場合は Settings の保存値を更新（DB暗号化値が更新されます）

- **APP_CONFIG_ENCRYPTION_KEY**
  - **原則: みだりに変更しない**（DBの暗号化済み値が復号できなくなります）
  - 変更が必要な場合は、事前に「再暗号化移行手順」を用意してから実施してください

### 2) もし秘密をコミットしてしまったら（事故対応）

前提:

- **公開リポジトリに1度出た秘密は「漏洩した」とみなす**のが安全です

やること（最優先）:

1. **キーの失効/再発行**（サービス提供側で実施）
2. ローカル/Settings保存値/CI等の参照先を新キーへ更新

Git側の対応（再発防止）:

- 該当ファイルを `.gitignore` で無視できているか確認（このリポジトリは `.env*` を無視します）
- 誤ってコミットした履歴を消す場合は、運用に合わせてリポジトリ管理者の手順に従ってください\n  （履歴改変は影響が大きいため、ここではコマンド手順は固定しません）

### 3) ログに秘密を出さない

- APIのエラー出力や、tool結果の生ログにキーが混ざらないようにします
- 「ツール実行ログをユーザーに読み上げる」系の事故は、UI/プロンプトだけでなく API 層で防ぎます

## チェックリスト（レビュー用）

- `.env.local` をコミットしていない
- APIキーを Issue / PR / スクショに貼っていない
- `APP_CONFIG_ENCRYPTION_KEY` を共有しない（共有するなら安全な秘密管理を使う）

